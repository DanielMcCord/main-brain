import { randomBytes } from 'crypto';

export class Turn {
    /**
     * @param {number[]} guess 
     * @param {number[]} result 
     */
    constructor(guess, result) {
        this.guess = guess;
        this.result = result;
    }
}

export class Round {
    /**
     * @param {number[]} [secret]
     * @param {Turn[]} [turns]
     * @param {number} [maxTurns]
     * @param {boolean} [allowRepeats]
     * @param {number} [codeLength]
     * @param {number} [choices]
     */
    constructor(
        secret,
        turns = [],
        maxTurns = 10,
        allowRepeats = true,
        codeLength = 4,
        choices = 6
    ) {
        this.turns = turns;
        this.maxTurns = maxTurns;
        this.allowRepeats = allowRepeats;
        this.codeLength = codeLength;
        this.choices = choices;
        this.secret = secret ??
            getNewCode(choices, codeLength, undefined, allowRepeats);
    }

    turnsRemaining() {
        return this.maxTurns - this.turns.length;
    }

    /**
     * 
     * @param {number[]} guess
     */
    recordTurn(turn) {
        this.turns.push(turn);
    }
}

/**
 * Returns a pseudorandom integer in the range [0, n).
 * Numbers generated by this function are not cryptographically secure.
 * Time complexity is O(1).
 * Use `getCryptoRandomInteger()` instead if security is needed.
 * @param {number} n Should be <= Number.MAX_SAFE_INTEGER
 * @returns {number} An integer.
 */
function getRandomInteger(n) {
    return Math.trunc(Math.random() * Math.ceil(Math.abs(n)) * Math.sign(n));
}

/**
 * Returns an integer in the range [0, n) using a
 * Cryptographically Secure Pseudo-Random Number Generator (CSPRNG).
 * Time complexity is O(log n).
 * Use `getRandomInteger()` instead if security is not needed.
 * @param {number} n Should be <= Number.MAX_SAFE_INTEGER
 * @returns {number} An integer.
 */
function getCryptoRandomInteger(n) {
    // Keep track of the sign so it can be multiplied back in at the end.
    const sign = Math.sign(n);

    // The main part of the algorithm only understands positive integers.
    const abs = Math.ceil(Math.abs(n));

    // Handle various special cases.
    if (!(abs > 1) || !isFinite(abs)) return (abs - 1) * sign;

    // Find the minimum bytes needed to express the largest possible number
    let byteCount = 0;
    // Converting this loop into a call to Math.log2() proved error-prone,
    // so I scrapped that idea.
    for (let temp = abs - 1; temp > 0; byteCount++, temp >>= 8);

    // Find the largest number that might be generated by the crypto API.
    const maxGenerableNum = parseInt('ff'.repeat(byteCount), 16);

    // Anything higher than this would introduce a modulo bias.
    const maxAcceptableNum = maxGenerableNum - maxGenerableNum % abs;

    // Loop ends in one iteration if n is a power of 2.
    // If abs < 32, it has more than a 90% chance of ending each iteration.
    // Regardless of abs, the chance each iteration is always at least 50%.
    while (true) {
        // Only request the bare minimum random bytes from crypto.randomBytes()
        const generatedNum = parseInt(randomBytes(byteCount).toString('hex'), 16);
        if (generatedNum <= maxAcceptableNum) return generatedNum % abs * sign;
    }
}

/**
 * Generate a code to be used for a round of the game.
 * Does not use cryptographically secure randomness by default.
 * @param {number} [choices] Integer. Number of "colors". Default is 6.
 * @param {number} [length] Integer. The length of the code. Default is 4.
 * @param {boolean} [casinoMode] Whether to use CSPRNG. Default is false.
 * @param {boolean} [repeats] Whether repeats are allowed. Default is true.
 */
export function getNewCode(
    choices = 6, length = 4, casinoMode = false, repeats = true
) {
    const randIntFn = casinoMode ? getCryptoRandomInteger : getRandomInteger;
    return Array(length).fill().map((x) => randIntFn(choices));
}

/**
 * An implementation of the Fisher-Yates-Knuth Shuffle algorithm.
 * @param {*[]} array The array to be shuffled.
 */
function shuffleInPlace(array) {
    // How the algorithm is supposed to work:
    //     For each element of the array, swap the current element with 
    //     a random element that has not been the current element prior to the
    //     current iteration. Allowing an element to swap with itself is
    //     mandatory, otherwise 

    // Looping backwards makes the random number calculations simpler.
    for (let i = array.length - 1; i >= 0; i--) {
        // In general, it's best to use crypto for shuffles.
        const r = getCryptoRandomInteger(i + 1);
        // Sometimes, `r` will equal `i` here. This is expected behavior.
        [array[i], array[r]] = [array[r], array[i]];
    }
}

/**
 * Returns an array containing integers in range [0, length) in a random order.
 * @param {number} length An integer.
 */
export function getShuffleOrder(length) {
    const order = [...Array(length).keys()];
    shuffleInPlace(order);
    return order;
}

/**
 * Returns how many positions in the guess exactly match the secret,
 * and how many are the correct value but in the wrong position.
 * @param {number[]} secret
 * @param {number[]} guess
 */
export function checkCode(secret, guess) {
    // Shuffle both the secret and guess to mitigate obvious timing attacks.
    // Use the same index mapping for both to preserve correctness.
    const shuffledIndices = getShuffleOrder(secret.length);
    const shuffledSecret = shuffledIndices.map((e) => secret[e]);
    const shuffledGuess = shuffledIndices.map((e) => guess[e]);

    // temporary arrays to track where matches have already been found,
    // based on the shuffled index order.
    const secretMatched = [];
    const guessMatched = [];

    // Mark exact matches in the temporary arrays with the number 1.
    for (let i = 0; i < secret.length; i++) {
        secretMatched[i] = guessMatched[i] = ((shuffledSecret[i] === shuffledGuess[i]) ? 1 : 0);
    }

    // Mark "wrong place" matches in the temporary arrays with the number 2.
    for (let i = 0; i < secret.length; i++) {
        for (let j = 0; j < secret.length; j++) {
            // Only check for matches with elements not already matched.
            if (!guessMatched[i] && !secretMatched[j] && (shuffledGuess[i] === shuffledSecret[j])) {
                guessMatched[i] = secretMatched[j] = 2;
                // Keep going, to mitigate another category of timing attacks.
            }
        }
    }

    return guessMatched.reduce((acc, current) => {
        switch (current) {
            case 1:
                return [acc[0] + 1, acc[1]];
            case 2:
                return [acc[0], acc[1] + 1];
            default:
                return acc;
        }
    }, [0, 0]);
}